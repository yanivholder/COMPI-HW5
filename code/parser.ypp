%{
    #include "parser_funcs.hpp"

	using namespace output;

	SymbolTable symbolTable = SymbolTable();
	CodeBuffer& buffer = CodeBuffer::instance();

	extern int yylineno;
	int yyerror(const char * message);
    extern int yylex();
    extern char* yytext;

    extern SymbolTable symbolTable;
    string curr_func_ret_type("");
    string curr_exp_type("");
    int during_while = 0;
    int during_switch = 0;
    string frame_pointer;
    int args_amount;
    bool return_happened = false;


%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL

%token TRUE
%token FALSE
%token RETURN

%nonassoc IF
%nonassoc ELSE


%token WHILE
%token BREAK
%token CONTINUE
%token SWITCH
%token CASE
%token DEFAULT
%token COLON
%token SC
%token COMMA

%token LBRACE
%token RBRACE

%token ID
%token NUM
%token STRING

%right ASSIGN

%left OR
%left AND

%left RELOP_EQ
%left RELOP_NOT_EQ

%nonassoc RELOP_LT;
%nonassoc RELOP_GT;
%nonassoc RELOP_LTE;
%nonassoc RELOP_GTE;

%left BINOP_ADD;
%left BINOP_SUB;
%left BINOP_MUL;
%left BINOP_DIV;

%right NOT

%nonassoc RPAREN
%nonassoc LPAREN

%type<exp> Exp;
%type<exp> Type;
%type<exp> RetType;
%type<funcArgsList> FormalsList;
%type<funcArgsList> Formals;
%type<funcArg> FormalDecl;
%type<expList> ExpList;
%type<exp> Call;
%type<id> ID;
%type<exp> NUM;

/* TODO add all the new types */
%type<label> MarkInIF;
%type<label> M;
%type<block> N;
%type<block> Statement;
%type<block> Statements;
%type<scope> IfScope;
%type<scope> ElseScope;
%type<case_stack> CaseList;
%type<case_struct> CaseDecl;



%%


Program     :   { declarePrerequisites(buffer); } Funcs                     { symbolTable.close_global_scope(); }

Funcs       :   /* epsilon */                                               {
                                                                                if(string(yytext) != "") {
                                                                                    yyerror(nullptr);
                                                                                }
                                                                            }
            |   FuncDecl Funcs                                              { }

FuncDecl    :   RetType ID LPAREN Formals RPAREN                            { return_happened = false; symbolTable.add_func_symbol($2->m_name, $1->m_type, $4->m_argsList); }

                LBRACE                                                      {
                                                                              symbolTable.open_scope();
                                                                              curr_func_ret_type = $1->m_type;
                                                                              symbolTable.add_func_args($4->m_argsList);

                                                                              string ir_ret_type = curr_func_ret_type == "VOID" ? "void" : "i32";
                                                                              FuncSymbol* func_sym = dynamic_cast<FuncSymbol*>(symbolTable.search_symbol($2->m_name, true));

                                                                              buffer.emit("define " + ir_ret_type + " @" + $2->m_name + func_sym->ir_params() + " {");
                                                                              frame_pointer = Generator::new_tmp();
                                                                              args_amount = $4->m_argsList.size();
                                                                              buffer.emit(frame_pointer + " = alloca [" + to_string(50 + args_amount) + " x i32]");
                                                                              for (int i = 0; i < args_amount; i++) {
                                                                                 string index = to_string(args_amount - i - 1);
                                                                                 string reg = "%" + to_string(i);
                                                                                 string ptr = Generator::new_tmp();
                                                                                 buffer.emit(ptr + " = getelementptr [" + to_string(50 + args_amount) + " x i32], [" + to_string(50 + args_amount) + " x i32]* " + frame_pointer + ", i32 0, i32 " + index);
                                                                                 buffer.emit("store i32 " + reg + ", i32* " + ptr);
                                                                              }
                                                                            }

                Statements RBRACE                                           {
                                                                                symbolTable.close_scope();
                                                                                if(return_happened == false) {
                                                                                    if(curr_func_ret_type == "VOID") {
                                                                                        buffer.emit("ret void");
                                                                                    }
                                                                                    else {
                                                                                        string ret_val = Generator::new_tmp();
                                                                                        buffer.emit(ret_val + " = add i32 0, 0");
                                                                                        buffer.emit("ret i32 " + ret_val);
                                                                                    }
                                                                                }
                                                                                buffer.emit("}");
                                                                                curr_func_ret_type = "";
                                                                            }

RetType     :   Type                                                        { $$ = new Exp($1->m_type); }
            |   VOID                                                        { $$ = new Exp("VOID"); }

Formals     :   FormalsList                                                 { $$->m_argsList = $1->m_argsList; }
            |   /* epsilon */                                               { $$ = new FuncArgsList(); }

FormalsList     :   FormalDecl                                              {
                                                                              $$ = new FuncArgsList();
                                                                              $$->m_argsList.push_back($1->m_arg);
                                                                            }
                |   FormalDecl COMMA FormalsList                            {
                                                                                $$ = new FuncArgsList();
                                                                                $$->m_argsList = $3->m_argsList;
                                                                                $$->m_argsList.push_back($1->m_arg);
                                                                            }

FormalDecl      :   Type ID                                                   { $$ = new FuncArg($1->m_type, $2->m_name); }

IfScope         :   IF LPAREN Exp RPAREN MarkInIF OpenScope Statement CloseScope { $$ = new Scope($3, $5->m_label, $7->m_nextList, $7->m_breakList, $7->m_continueList); }

ElseScope       :   ELSE N M OpenScope Statement CloseScope                 { $$ = new Scope(nullptr, $3->m_label, buffer.merge($2->m_nextList, $5->m_nextList), buffer.merge($2->m_breakList, $5->m_breakList), buffer.merge($2->m_continueList, $5->m_continueList)); }

OpenScope   :   /* epsilon */                                               { symbolTable.open_scope(); }

CloseScope  :   /* epsilon */                                               { symbolTable.close_scope(); }

M           :   /* epsilon */                                               { $$ = new Label(buffer.genLabel()); }

N           :   /* epsilon */                                               {
                                                                              int address = buffer.emit("br label @");
                                                                              $$ = new Block();
                                                                              $$->m_nextList = CodeBuffer::makelist({address, FIRST});
                                                                            }

Statements      :   Statement                                               {
                                                                              $$ = new Block();
                                                                              $$->m_nextList = $1->m_nextList;
                                                                              $$->m_breakList = $1->m_breakList;
                                                                              $$->m_continueList = $1->m_continueList;
                                                                            }
                |   Statements Statement                                    {
                                                                                $$ = new Block();
                                                                                $$->m_nextList = CodeBuffer::merge($1->m_nextList, $2->m_nextList);
                                                                                $$->m_breakList = CodeBuffer::merge($1->m_breakList, $2->m_breakList);
                                                                                $$->m_continueList = CodeBuffer::merge($1->m_continueList, $2->m_continueList);
                                                                            }

Statement       :   LBRACE OpenScope Statements RBRACE CloseScope           {
                                                                                $$ = new Block();
                                                                                $$->m_nextList = $3->m_nextList;
                                                                                $$->m_breakList = $3->m_breakList;
                                                                                $$->m_continueList = $3->m_continueList;
                                                                            }
                |   Type ID SC                                              {
                                                                                symbolTable.add_var_symbol($2->m_name, $1->m_type);
                                                                                string offset = to_string(symbolTable.search_symbol($2->m_name, false)->offset + args_amount);
                                                                                string ptr = Generator::new_tmp();

                                                                                buffer.emit(ptr + " = getelementptr [" + to_string(50 + args_amount) + " x i32], [" + to_string(50 + args_amount) + " x i32]* " + frame_pointer + ", i32 0, i32 " + offset);
                                                                                buffer.emit("store i32 0, i32* " + ptr);
                                                                                $$ = new Block();
                                                                            }
                |   Type ID ASSIGN Exp SC                                   {
                                                                                validate_assign($1->m_type, $4->m_type);
                                                                                symbolTable.add_var_symbol($2->m_name, $1->m_type);

                                                                                if ($1->m_type == "BOOL") {
                                                                                    exp_to_bool($4, buffer);
                                                                                }

                                                                                string offset = to_string(symbolTable.search_symbol($2->m_name, false)->offset + args_amount);
                                                                                string ptr = Generator::new_tmp();

                                                                                buffer.emit(ptr + " = getelementptr [" + to_string(50 + args_amount) + " x i32], [" + to_string(50 + args_amount) + " x i32]* " + frame_pointer + ", i32 0, i32 " + offset);
                                                                                buffer.emit("store i32 " + $4->m_reg + ", i32* " + ptr);
                                                                                $$ = new Block();
                                                                            }
                |   ID ASSIGN Exp SC                                        {
                                                                                string type = get_var_type($1->m_name, symbolTable);
                                                                                validate_assign(type, $3->m_type);

                                                                                if (type == "BOOL") {
                                                                                    exp_to_bool($3, buffer);
                                                                                }

                                                                                string offset = to_string(symbolTable.search_symbol($1->m_name, false)->offset + args_amount);
                                                                                string ptr = Generator::new_tmp();

                                                                                buffer.emit(ptr + " = getelementptr [" + to_string(50 + args_amount) + " x i32], [" + to_string(50 + args_amount) + " x i32]* " + frame_pointer + ", i32 0, i32 " + offset);
                                                                                buffer.emit("store i32 " + $3->m_reg + ", i32* " + ptr);
                                                                                $$ = new Block();
                                                                            }
                |   Call SC                                                 {
                                                                                $$ = new Block();
                                                                                if ($1->m_type == "BOOL") {
                                                                                    string nextLabel = buffer.genLabel();
                                                                                    buffer.bpatch($1->m_trueList, nextLabel);
                                                                                    buffer.bpatch($1->m_falseList, nextLabel);
                                                                                }
                                                                            }
                |   RETURN SC                                               {
                                                                                return_happened = true;
                                                                                vaildate_type(curr_func_ret_type, "VOID");
                                                                                buffer.emit("ret void");
                                                                                $$ = new Block();
                                                                            }
                |   RETURN Exp SC                                           {
                                                                                return_happened = true;
                                                                                validate_assign(curr_func_ret_type, $2->m_type);

                                                                                if (curr_func_ret_type == "BOOL") {
                                                                                    exp_to_bool($2, buffer);
                                                                                }

                                                                                buffer.emit("ret i32 " + $2->m_reg);
                                                                                $$ = new Block();
                                                                            }
                |   IfScope %prec IF
                                                                            {
                                                                                buffer.bpatch($1->m_exp->m_trueList, $1->m_label);
                                                                                $$ = new Block();
                                                                                $$->m_breakList = $1->m_block->m_breakList;
                                                                                $$->m_continueList = $1->m_block->m_continueList;
                                                                                $$->m_nextList = CodeBuffer::merge($1->m_exp->m_falseList, $1->m_block->m_nextList);
                                                                                int address = buffer.emit("br label @");
                                                                                $$->m_nextList = CodeBuffer::merge($$->m_nextList, CodeBuffer::makelist({address, FIRST}));
                                                                                string label = buffer.genLabel();
                                                                                buffer.bpatch($$->m_nextList, label);
                                                                            }
                |   IfScope ElseScope
                                                                            {
                                                                                buffer.bpatch($1->m_exp->m_falseList, $2->m_label);
                                                                                buffer.bpatch($1->m_exp->m_trueList, $1->m_label);

                                                                                $$ = new Block();
                                                                                $$->m_breakList = CodeBuffer::merge($1->m_block->m_breakList, $2->m_block->m_breakList);
                                                                                $$->m_continueList = CodeBuffer::merge($1->m_block->m_continueList, $2->m_block->m_continueList);
                                                                                $$->m_nextList = CodeBuffer::merge($1->m_block->m_nextList, $2->m_block->m_nextList);
                                                                                // $$->m_nextList = CodeBuffer::merge($$->m_nextList, $9->m_nextList);

                                                                                int address = buffer.emit("br label @");
                                                                                $$->m_nextList = CodeBuffer::merge($$->m_nextList, CodeBuffer::makelist({address, FIRST}));
                                                                                string label = buffer.genLabel();
                                                                                buffer.bpatch($$->m_nextList, label);
                                                                            }
                |   WHILE LPAREN N M Exp RPAREN                             {
                                                                                vaildate_type($5->m_type, "BOOL");
                                                                                during_while++;
                                                                                symbolTable.open_scope();
                                                                            }
                    M Statement                                             {
                                                                                symbolTable.close_scope();
                                                                                during_while--;
                                                                                $$ = new Block();
                                                                                buffer.bpatch($9->m_continueList, $4->m_label);
                                                                                buffer.bpatch($5->m_trueList, $8->m_label);
                                                                                buffer.bpatch($9->m_nextList, $4->m_label);
                                                                                buffer.bpatch($3->m_nextList, $4->m_label);
                                                                                $$->m_nextList = CodeBuffer::merge($5->m_falseList, $9->m_breakList);
                                                                                buffer.emit("br label %" + $4->m_label);
                                                                                string label = buffer.genLabel();
                                                                                // buffer.bpatch($$->m_nextList, label);
                                                                                buffer.bpatch($9->m_breakList, label);
                                                                                buffer.bpatch($5->m_falseList, label);
                                                                            }
                |   BREAK SC                                                {
                                                                                if(!during_while && !during_switch) {
                                                                                    errorUnexpectedBreak(yylineno);
                                                                                    exit(1);
                                                                                }

                                                                                $$ = new Block();
                                                                                int address = buffer.emit("br label @");
                                                                                $$->m_breakList = CodeBuffer::makelist({address, FIRST});
                                                                            }
                |   CONTINUE SC                                             {
                                                                                if(!during_while) {
                                                                                    errorUnexpectedContinue(yylineno);
                                                                                    exit(1);
                                                                                }

                                                                                $$ = new Block();
                                                                                int address = buffer.emit("br label @");
                                                                                $$->m_continueList = CodeBuffer::makelist({address, FIRST});
                                                                            }
                |   SWITCH LPAREN Exp N RPAREN                              {
                                                                                validate_assign("INT", $3->m_type);
                                                                                during_switch++;
                                                                            }
                    LBRACE OpenScope CaseList RBRACE CloseScope             {   
                                                                                $$ = new Block();

                                                                                buffer.bpatch($4->m_nextList, buffer.genLabel());
                                                                                string switch_cmd = "switch i32 " +  to_string($3->m_val) + ", ";
                                                                                if ($9->default_case != nullptr)
                                                                                {
                                                                                    switch_cmd += "label " + $9->default_case->m_label + " [ ";
                                                                                }
                                                                                else{
                                                                                    switch_cmd += "label @ [ ";
                                                                                }
                                                                                while(!$9->case_stack.empty()) {
                                                                                    Case* c = $9->case_stack.top();
                                                                                    switch_cmd += "i32 " + to_string(c->m_val) + ", label " + c->m_label + " ";
                                                                                    $$->m_continueList = CodeBuffer::merge($$->m_continueList, c->statements->m_continueList);
                                                                                    $$->m_breakList = CodeBuffer::merge($$->m_breakList, c->statements->m_breakList);
                                                                                    $$->m_continueList = CodeBuffer::merge($$->m_continueList, c->statements->m_continueList);

                                                                                    $9->case_stack.pop();

                                                                                }
                                                                                switch_cmd += "]";

                                                                                int address = buffer.emit(switch_cmd);

                                                                                $$->m_nextList = CodeBuffer::merge($$->m_nextList, CodeBuffer::makelist({address, FIRST}));
                                                                                $$->m_nextList = CodeBuffer::merge($$->m_nextList, $$->m_breakList);

                                                                                int address2 = buffer.emit("br label @");
                                                                                $$->m_nextList = CodeBuffer::merge($$->m_nextList, CodeBuffer::makelist({address2, FIRST}));
                                                                                string label = buffer.genLabel();
                                                                                buffer.bpatch($$->m_nextList, label);

                                                                                during_switch--;
                                                                            }

MarkInIF    :  /* epsilon */                                                {
                                                                                vaildate_type(curr_exp_type, "BOOL");
                                                                                $$ = new Label(buffer.genLabel());
                                                                            }


Call        :   ID LPAREN ExpList RPAREN                                    {
                                                                                FuncSymbol* f = get_func($1->m_name, $3->m_typeList, symbolTable);
                                                                                $$ = new Exp(f->return_type);
                                                                                if ($1->m_name == "print") {
                                                                                    auto strExp = $3->m_exp.at(0);
                                                                                    buffer.emit("call void @print(i8* getelementptr ([" + strExp->m_size + " x i8], [" + strExp->m_size + " x i8]* " + strExp->m_reg + ", i32 0, i32 0))");
                                                                                } else {
                                                                                    call_to_ir($$, $1, $3, f, true, buffer);
                                                                                }
                                                                            }
            |   ID LPAREN RPAREN                                            {
            																	std::vector<string> v;
                                                                                FuncSymbol* f = get_func($1->m_name, v, symbolTable);
                                                                                $$ = new Exp(f->return_type);
                                                                                
                                                                                call_to_ir($$, $1, nullptr, f, false, buffer);
                                                                            }

ExpList     :   Exp                                                         {
                                                                              $$ = new ExpList();
                                                                              $$->m_typeList.push_back($1->m_type);
                                                                              $$->m_exp.push_back($1);
                                                                              if ($1->m_type == "BOOL") {
                                                                                  exp_to_bool($1, buffer);
                                                                              }
                                                                            }
            |   Exp COMMA ExpList                                           {
                                                                                $$ = new ExpList();
                                                                                $$->m_typeList = $3->m_typeList;
                                                                                $$->m_typeList.push_back($1->m_type);
                                                                                $$->m_exp = $3->m_exp;
                                                                                $$->m_exp.push_back($1);
                                                                                if ($1->m_type == "BOOL") {
                                                                                    exp_to_bool($1, buffer);
                                                                                }
                                                                            }

Type        :   INT                                                         { $$ = new Exp("INT"); }
            |   BYTE                                                        { $$ = new Exp("BYTE"); }
            |   BOOL                                                        { $$ = new Exp("BOOL"); }

Exp         :   LPAREN Exp RPAREN                                           {
                                                                                $$ = new Exp($2->m_type);
                                                                                curr_exp_type = $2->m_type;

                                                                                $$->m_reg = $2->m_reg;
                                                                                $$->m_trueList = $2->m_trueList;
                                                                                $$->m_falseList = $2->m_falseList;
                                                                            }
            |   Exp BINOP_ADD Exp                                           { $$ = do_op($1, $3, PBINOP, "add", buffer); curr_exp_type = $$->m_type; }
            |   Exp BINOP_SUB Exp                                           { $$ = do_op($1, $3, PBINOP, "sub", buffer); curr_exp_type = $$->m_type; }
            |   Exp BINOP_MUL Exp                                           { $$ = do_op($1, $3, PBINOP, "mul", buffer); curr_exp_type = $$->m_type; }
            |   Exp BINOP_DIV Exp                                           { $$ = do_op($1, $3, PBINOP, "sdiv", buffer); curr_exp_type = $$->m_type; }
            |   ID                                                          {
                                                                              auto sym = symbolTable.search_symbol($1->m_name, false);
                                                                              string type = get_var_type($1->m_name, symbolTable);
                                                                              $$ = new Exp(type);
                                                                              $$->m_name = $1->m_name;
                                                                              curr_exp_type = type;

                                                                              string ptr = Generator::new_tmp();
                                                                              $$->m_reg = Generator::new_tmp();
                                                                              string offset = to_string(sym->offset + args_amount);
                                                                              buffer.emit(ptr + " = getelementptr [" + to_string(50 + args_amount) + " x i32], [" + to_string(50 + args_amount) + " x i32]* " + frame_pointer + ", i32 0, i32 " + offset);
                                                                              buffer.emit($$->m_reg + " = load i32, i32* " + ptr);

                                                                              if (sym->type == "BOOL") {
                                                                                  string cond = Generator::new_tmp();
                                                                                  buffer.emit(cond + " = icmp eq i32 " + $$->m_reg + ", 1");
                                                                                  int address = buffer.emit("br i1 " + cond + ", label @, label @");
                                                                                  $$->m_trueList = CodeBuffer::merge($$->m_trueList, CodeBuffer::makelist({address, FIRST}));
                                                                                  $$->m_falseList = CodeBuffer::merge($$->m_falseList, CodeBuffer::makelist({address, SECOND}));
                                                                              }
                                                                            }
            |   Call                                                        {
                                                                                $$ = new Exp($1->m_type);
                                                                                curr_exp_type = $1->m_type;

                                                                                if ($$->m_type != "VOID") {
                                                                                    $$->m_reg = $1->m_reg;
                                                                                }
                                                                                $$->m_trueList = $1->m_trueList;
                                                                                $$->m_falseList = $1->m_falseList;
                                                                            }
            |   NUM                                                         {
                                                                                $$ = new Exp("INT");
                                                                                curr_exp_type = "INT";

                                                                                $$->m_reg = Generator::new_tmp();
                                                                                buffer.emit($$->m_reg + " = add i32 0, " + to_string(yylval.val));
                                                                            }
            |   NUM B                                                       {
                                                                                if (yylval.val > 255) {
                                                                                    errorByteTooLarge(yylineno, to_string(yylval.val));
                                                                                    exit(1);
                                                                                }
                                                                                $$ = new Exp("BYTE");
                                                                                curr_exp_type = "BYTE";

                                                                                $$->m_reg = Generator::new_tmp();
                                                                                buffer.emit($$->m_reg + " = add i32 0, " + to_string(yylval.val));
                                                                            }
            |   STRING                                                      {
                                                                                $$ = new Exp("STRING");
                                                                                curr_exp_type = "STRING";

                                                                                $$->m_reg = Generator::new_string();
                                                                                $$->m_size = to_string(yylval.id->m_name.size() + 1);
                                                                                buffer.emitGlobal($$->m_reg + " = global [" + $$->m_size + " x i8] c\"" + yylval.id->m_name + "\\00\"");
                                                                            }
            |   TRUE                                                        {
                                                                                $$ = new Exp("BOOL");
                                                                                curr_exp_type = "BOOL";

                                                                                int address = buffer.emit("br label @");
                                                                                $$->m_trueList = CodeBuffer::merge($$->m_trueList, CodeBuffer::makelist({address, FIRST}));

                                                                            }
            |   FALSE                                                       {
                                                                                $$ = new Exp("BOOL");
                                                                                curr_exp_type = "BOOL";

                                                                                int address = buffer.emit("br label @");
                                                                                $$->m_falseList = CodeBuffer::merge($$->m_falseList, CodeBuffer::makelist({address, FIRST}));
                                                                            }
            |   NOT Exp                                                     { $$ = do_op($2, $2, PNOT, "", buffer); curr_exp_type = "BOOL"; }
            |   Exp AND M Exp                                               {
                                                                                buffer.bpatch($1->m_trueList, $3->m_label);
                                                                                $$ = do_op($1, $4, PAND, "", buffer);
                                                                            }
            |   Exp OR M Exp                                                {
                                                                                buffer.bpatch($1->m_falseList, $3->m_label);
                                                                                $$ = do_op($1, $4, POR, "", buffer);
                                                                            }
            |   Exp RELOP_EQ Exp                                            { $$ = do_op($1, $3, PRELOP, "eq", buffer); curr_exp_type = "BOOL"; }
            |   Exp RELOP_NOT_EQ Exp                                        { $$ = do_op($1, $3, PRELOP, "ne", buffer); curr_exp_type = "BOOL"; }
            |   Exp RELOP_LT Exp                                            { $$ = do_op($1, $3, PRELOP, "slt", buffer); curr_exp_type = "BOOL"; }
            |   Exp RELOP_GT Exp                                            { $$ = do_op($1, $3, PRELOP, "sgt", buffer); curr_exp_type = "BOOL"; }
            |   Exp RELOP_LTE Exp                                           { $$ = do_op($1, $3, PRELOP, "sle", buffer); curr_exp_type = "BOOL"; }
            |   Exp RELOP_GTE Exp                                           { $$ = do_op($1, $3, PRELOP, "sge", buffer); curr_exp_type = "BOOL"; }

CaseList         :   CaseDecl CaseList                                      { 
                                                                                $$ = new CaseStack($2->case_stack);
                                                                                $$->case_stack.push($1);
                                                                                $$->m_nextList = CodeBuffer::merge($1->statements->m_nextList, $2->m_nextList);
                                                                            }
                 |   CaseDecl                                               { 
                                                                                $$ = new CaseStack();
                                                                                $$->case_stack.push($1);
                                                                                $$->default_case  = nullptr;
                                                                            }
                 |   DEFAULT COLON M Statements                             {   
                                                                                $$ = new CaseStack();
                                                                                $$->default_case  = new Case(0, $3->m_label, $4);
                                                                            }

CaseDecl        :   CASE NUM COLON M Statements                             {   $$ = new Case($2->m_val, $4->m_label, $5); }


%%

int main(){
    yyparse();
    buffer.printGlobalBuffer();
    buffer.printCodeBuffer();
}
int yyerror(const char* message) {
	errorSyn(yylineno);
	exit(1);
}


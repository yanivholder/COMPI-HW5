%{
    #include "parser_funcs.hpp"

	using namespace output;

	extern int yylineno;
	int yyerror(const char * message);
    extern int yylex();
    extern char* yytext;

    extern SymbolTable symbolTable;
    string curr_func_ret_type("");
    string curr_exp_type("");
    int during_while = 0;
    int during_switch = 0;
    string frame_pointer;
    int args_amount;
    bool return_happened = false;


%}

%token VOID
%token INT
%token BYTE
%token B
%token BOOL

%token TRUE
%token FALSE
%token RETURN
%token IF

%token WHILE
%token BREAK
%token CONTINUE
%token SWITCH
%token CASE
%token DEFAULT
%token COLON
%token SC
%token COMMA

%token LBRACE
%token RBRACE

%token ID
%token NUM
%token STRING

%right ASSIGN

%left OR
%left AND

%left RELOP_EQ
%left RELOP_NOT_EQ

%nonassoc RELOP_LT;
%nonassoc RELOP_GT;
%nonassoc RELOP_LTE;
%nonassoc RELOP_GTE;

%left BINOP_ADD;
%left BINOP_SUB;
%left BINOP_MUL;
%left BINOP_DIV;

%right NOT

%nonassoc RPAREN
%nonassoc LPAREN
%nonassoc ELSE

%type<exp> Exp;
%type<exp> Type;
%type<exp> RetType;
%type<funcArgsList> FormalsList;
%type<funcArgsList> Formals;
%type<funcArg> FormalDecl;
%type<typeList> ExpList;
%type<exp> Call;
%type<id> ID;
%type<exp> NUM;

/* TODO add all the new types */

%type<label> M;
%type<block> N;
%type<block> Statement;
%type<block> Statements;

%%


Program     :   Funcs                                                       { symbolTable.close_global_scope(); }

Funcs       :   /* epsilon */                                               {
                                                                                if(string(yytext) != "") {
                                                                                    yyerror(nullptr);
                                                                                }
                                                                            }
            |   FuncDecl Funcs                                              { }

FuncDecl    :   RetType ID LPAREN Formals RPAREN                            { return_happened = false; symbolTable.add_func_symbol($2->m_name, $1->m_type, $4->m_argsList); }

                LBRACE                                                      {
                                                                              symbolTable.open_scope();
                                                                              curr_func_ret_type = $1->m_type;
                                                                              symbolTable.add_func_args($4->m_argsList);

                                                                              string ir_ret_type = curr_func_ret_type == "VOID" ? "void" : "i32";
                                                                              auto func_sym = symbolTable.search_symbol($2->m_name, true);

                                                                              buffer.emit("define " + ir_ret_type + " @" + $2->m_name + func_sym->ir_params() + " {");
                                                                              frame_pointer = Generator::new_tmp();
                                                                              int args_amount = $4->m_argsList.size();
                                                                              for (int i = 0; i < args_amount; i++) {
                                                                                 string index = to_string(args_amount - i - 1);
                                                                                 string reg = "%" + to_string(i);
                                                                                 string ptr = Generator::new_tmp();
                                                                                 buffer.emit(ptr + " = getelementptr [" + to_string(50 + args_amount) + " x i32], [" + to_string(50 + args_amount) + " x i32]* " + frame_pointer + ", i32 0, i32 " + index);
                                                                                 buffer.emit("store i32 " + reg + ", i32* " + ptr);
                                                                              }
                                                                            }

                Statements RBRACE                                           {
                                                                                symbolTable.close_scope();
                                                                                if(return_happened == false) {
                                                                                    if(curr_func_ret_type == "VOID") {
                                                                                        buffer.emit("ret void");
                                                                                    }
                                                                                    else {
                                                                                        string ret_val = Generator::new_tmp();
                                                                                        buffer.emit(ret_val + " = add i32 0, 0");
                                                                                        buffer.emit("ret i32 " + ret_val);
                                                                                    }
                                                                                }
                                                                                buffer.emit("}");
                                                                                curr_func_ret_type = "";
                                                                            }

RetType     :   Type                                                        { $$ = new Exp($1->m_type); }
            |   VOID                                                        { $$ = new Exp("VOID"); }

Formals     :   FormalsList                                                 { $$->m_argsList = $1->m_argsList; }
            |   /* epsilon */                                               { $$ = new FuncArgsList(); }

FormalsList     :   FormalDecl                                              {
                                                                              $$ = new FuncArgsList();
                                                                              $$->m_argsList.push_back($1->m_arg);
                                                                            }
                |   FormalDecl COMMA FormalsList                            {
                                                                                $$ = new FuncArgsList();
                                                                                $$->m_argsList = $3->m_argsList;
                                                                                $$->m_argsList.push_back($1->m_arg);
                                                                            }

FormalDecl      : Type ID                                                   { $$ = new FuncArg($1->m_type, $2->m_name); }

Statements      :   Statement                                               { }
                |   Statements Statement                                    { }

Statement       :   LBRACE OpenScope Statements RBRACE CloseScope           { }
                |   Type ID SC                                              { symbolTable.add_var_symbol($2->m_name, $1->m_type); }
                |   Type ID ASSIGN Exp SC                                   {
                                                                                validate_assign($1->m_type, $4->m_type);
                                                                                symbolTable.add_var_symbol($2->m_name, $1->m_type);
                                                                            }
                |   ID ASSIGN Exp SC                                        {
                                                                                string type = get_var_type($1->m_name);
                                                                                validate_assign(type, $3->m_type);
                                                                            }
                |   Call SC                                                 { }
                |   RETURN SC                                               {
                                                                                return_happened = true;
                                                                                vaildate_type(curr_func_ret_type, "VOID");
                                                                                buffer.emit("ret i32 " + $2->m_reg);
                                                                            }
                |   RETURN Exp SC                                           {
                                                                                return_happened = true;
                                                                                validate_assign(curr_func_ret_type, $2->m_type);
                                                                                buffer.emit("ret void");
                                                                            }
                |   IF LPAREN Exp RPAREN MarkInIF OpenScope Statement CloseScope
                |   IF LPAREN Exp RPAREN MarkInIF OpenScope Statement CloseScope
                ELSE OpenScope Statement CloseScope
                |   WHILE LPAREN Exp RPAREN                                 {
                                                                                vaildate_type($3->m_type, "BOOL");
                                                                                during_while++;
                                                                                symbolTable.open_scope(); }
                    Statement                                               {
                                                                                symbolTable.close_scope();
                                                                                during_while--;
                                                                            }
                |   BREAK SC                                                {   if(!during_while && !during_switch) {errorUnexpectedBreak(yylineno); exit(1);} }
                |   CONTINUE SC                                             {   if(!during_while) {errorUnexpectedContinue(yylineno); exit(1);} }
                |   SWITCH LPAREN Exp RPAREN                                {
                                                                                validate_assign("INT", $3->m_type);
                                                                                during_switch++;
                                                                            }
                    LBRACE OpenScope CaseList RBRACE CloseScope             {   during_switch--; }

MarkInIF    :  /* epsilon */                                                { vaildate_type(curr_exp_type, "BOOL"); }


Call        :   ID LPAREN ExpList RPAREN                                    {
                                                                                FuncSymbol* f = get_func($1->m_name, $3->m_typeList);
                                                                                $$ = new Exp(f->return_type);
                                                                            }
            |   ID LPAREN RPAREN                                            {
                                                                                FuncSymbol* f = get_func($1->m_name, std::vector<string>());
                                                                                $$ = new Exp(f->return_type);
                                                                            }

ExpList     :   Exp                                                         {
                                                                              $$ = new TypeList();
                                                                              $$->m_typeList.push_back($1->m_type);
                                                                            }
            |   Exp COMMA ExpList                                           {
                                                                                $$ = new TypeList();
                                                                                $$->m_typeList = $3->m_typeList;
                                                                                $$->m_typeList.push_back($1->m_type);
                                                                            }

Type        :   INT                                                         { $$ = new Exp("INT"); }
            |   BYTE                                                        { $$ = new Exp("BYTE"); }
            |   BOOL                                                        { $$ = new Exp("BOOL"); }

Exp         :   LPAREN Exp RPAREN                                           { $$ = new Exp($2->m_type); curr_exp_type = "INT"; }
            |   Exp BINOP_ADD Exp                                           { $$ = do_op($1, $3, PBINOP, "add"); curr_exp_type = "INT"; }
            |   Exp BINOP_SUB Exp                                           { $$ = do_op($1, $3, PBINOP, "sub"); curr_exp_type = "INT"; }
            |   Exp BINOP_MUL Exp                                           { $$ = do_op($1, $3, PBINOP, "mul"); curr_exp_type = "INT"; }
            |   Exp BINOP_DIV Exp                                           { $$ = do_op($1, $3, PBINOP, "sdiv"); curr_exp_type = "INT"; }
            |   ID                                                          {
                                                                              string type = get_var_type($1->m_name);
                                                                              $$ = new Exp(type);
                                                                              $$->m_varName = $1->m_name;
                                                                              curr_exp_type = type;
                                                                            }
            |   Call                                                        { $$ = new Exp($1->m_type); curr_exp_type = $1->m_type; }
            |   NUM                                                         { $$ = new Exp("INT"); curr_exp_type = "INT"; }
            |   NUM B                                                       {
                                                                                if (yylval.val > 255) {
                                                                                    errorByteTooLarge(yylineno, to_string(yylval.val));
                                                                                    exit(1);
                                                                                }
                                                                                $$ = new Exp("BYTE");
                                                                                curr_exp_type = "BYTE";
                                                                            }
            |   STRING                                                      { $$ = new Exp("STRING"); curr_exp_type = "STRING";}
            |   TRUE                                                        { $$ = new Exp("BOOL"); curr_exp_type = "BOOL"; }
            |   FALSE                                                       { $$ = new Exp("BOOL"); curr_exp_type = "BOOL"; }
            |   NOT Exp                                                     { $$ = do_op($2, $2, PNOT); curr_exp_type = "BOOL"; }
            |   Exp AND M Exp                                               {
                                                                                buffer.bpatch($1->m_trueList, $3->m_label);
                                                                                $$ = do_op($1, $4, PAND);
                                                                            }
            |   Exp OR M Exp                                                {
                                                                                buffer.bpatch($1->m_falseList, $3->m_label);
                                                                                $$ = do_op($1, $4, POR);
                                                                            }
            |   Exp RELOP_EQ Exp                                            { $$ = do_op($1, $3, PRELOP, "eq"); curr_exp_type = "BOOL"; }
            |   Exp RELOP_NOT_EQ Exp                                        { $$ = do_op($1, $3, PRELOP, "ne"); curr_exp_type = "BOOL"; }
            |   Exp RELOP_LT Exp                                            { $$ = do_op($1, $3, PRELOP, "slt"); curr_exp_type = "BOOL"; }
            |   Exp RELOP_GT Exp                                            { $$ = do_op($1, $3, PRELOP, "sge"); curr_exp_type = "BOOL"; }
            |   Exp RELOP_LTE Exp                                           { $$ = do_op($1, $3, PRELOP, "sle"); curr_exp_type = "BOOL"; }
            |   Exp RELOP_GTE Exp                                           { $$ = do_op($1, $3, PRELOP, "sge"); curr_exp_type = "BOOL"; }

CaseList         :   CaseDecl CaseList                                      { }
                 |   CaseDecl                                               { }
                 |   DEFAULT COLON Statements                               { }

CaseDecl        :   CASE NUM COLON Statements                               { }

OpenScope   :   /* epsilon */                                               { symbolTable.open_scope(); }

CloseScope  :   /* epsilon */                                               { symbolTable.close_scope(); }

M           :   /* epsilon */                                               { $$ = new Label(buffer.genLabel()); }

N           :   /* epsilon */                                               {
                                                                              int address = buffer.emit("br label @");
                                                                              $$ = new Block();
                                                                              $$->m_nextList = buffer.makelist({address, FIRST});
                                                                            }

%%

int main() {
	return yyparse();
}

int yyerror(const char* message) {
	errorSyn(yylineno);
	exit(1);
}

